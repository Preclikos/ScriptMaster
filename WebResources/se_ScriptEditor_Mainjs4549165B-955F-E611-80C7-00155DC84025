/**Main App**/
window.ScriptEditor = function(config,$,Q)	{
	var _config = config;
	var _checkForLink = function(entry){
		var se = this;
		if(typeof(entry)=="object"&&typeof(entry.link)!="undefined"){
			var extract = config.NodeDataArray[entry.link]
			return se[extract.fName](extract.args);
		}else{
			return new Q.Promise(function(resolve,reject){resolve(entry)});
		}
	}
	
	var _buildServerUrl = function(entity,id,select,filter){
		// var entity = args[0];
		// var id = args[1];
		// var property = args[2];
		
		var returnURL = "";
		var clientURL = Xrm.Page.context.getClientUrl()
		var version = Xrm.Page.context.getVersion().substring(0,3);
		if(parseFloat(version)>=8){
			returnURL = clientURL+"/api/data/v"+version+"/";
			if(entity){
				returnURL += entity.toLowerCase()+"s";
				if(id){
					returnURL += "("+id+")"
					if(select[0]!=""){
						returnURL += "?$select="
						for(var i=0;i<select.length;i++){
							returnURL += select[i];
							if(i!=select.length-1){
								returnURL += ",";
							}
						}
					}
				}
			}
		}else{
			returnURL = clientURL+"/"
		}
		return returnURL;
		//TODO: finish this
	}
	
	/// <summary>
	/// Procces Math statement
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	operator {String} [+,-,*,/,all Math methods]
	/// @args[1]	:	left side value {Number,Link,Anything}
	/// @args[2]	:	right side value {Number,Link,Anything}
	/// </param>
	var proccesMathStatement = function(args){
		var se = this;

		return new Q.Promise(function(resolve,reject){
			var a = args[0];
			var b = se._checkForLink(args[1]);
			var c = se._checkForLink(args[2]);
			Q.Promise.all([b,c]).then(function(values){
				var left = values[0];
				var right = values[1];
				var result;
				if(a.length === 1){
					switch(a) {
						case "+":
							result = left + right;
							console.log("returning proccesMathStatement result: "+result);
							resolve(result);
							break;
						case "-":
							result = left - right;
							console.log("returning proccesMathStatement result: "+result);
							resolve(result);
							break;
						case "*":
							result = left * right;
							console.log("returning proccesMathStatement result: "+result);
							resolve(result);
							break;
						case "/":
							result = left / right;
							console.log("returning proccesMathStatement result: "+result);
							resolve(result);
							break;
					}
				}else if(a.length > 1){
					result = Math[a](left,right);
					console.log("returning proccesMathStatement: "+a+" with result: "+result);
					resolve(result);
				}
			});
		});
	}
	
	/// <summary>
	/// Procces String statement
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	operator {String} [join,substring,trim,...]
	/// @args[1]	:	array of string values {String,Link}["val1,{link:2},val3"]
	/// @args[2]	:	parameter1 {String,Number,Link,Anything}
	/// @args[3]	:	parameter2 {String,number,Link,Anything}
	/// </param>
	var proccesStringStatement = function(args){	//UNFINISHED
		var se = this;

		return new Q.Promise(function(resolve,reject){
			var a = args[0];
			/**process second argument of string values - check all for link and resolve value**/
			var b = args[1].split(",");
			var c = [];
			for(var i =0; i<b.length;i++){
				c.push(se._checkForLink(b[i]));
			}
			var prom = function(arr){
				return new Q.Promise(function(res,rej){
					Q.Promise.all(arr).then(function(vals){
						res(vals);
					})
				})
			}
			var f = prom(c);
			/***/
			//var b = se._checkForLink(args[1]);
			var d = se._checkForLink(args[2]);
			var e = se._checkForLink(args[3]);
			Q.Promise.all([f,d,e]).then(function(values){
				debugger;
				var strings = values[0];
				var par1 = values[1];
				var par2 = values[2];
				var result = "";
				resolve(result);
			});
		});
	}
	
	/// <summary>
	/// join Strings function
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	separator {String,Link}
	/// @args[1]	:	string1 {String,Number,Link,Anything}
	/// @args[2]	:	string2 {String,number,Link,Anything}
	/// </param>
	var concatStrings = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			var b = se._checkForLink(args[1]);
			var c = se._checkForLink(args[2]);
			Q.Promise.all([a,b,c]).then(function(values){
				var separator = values[0];
				var string1 = values[1];
				var string2 = values[2];
				
				var result = string1.concat(separator,string2);
				
				resolve(result);
			});
		});
	}
	
	/// <summary>
	/// Relay value from argument to return value
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0] : value {String,Link,Number}
	/// </param>
	var relayValue = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			Q.Promise.all([a]).then(function(values){
				var retVal = "";
				if(isNaN(parseFloat(values[0]))){
					retVal = values[0];
				}else{
					retVal = parseFloat(values[0]);
				}
				resolve(retVal);
			});
		});
	}
	
	/// <summary>
	/// Gets field value in current form
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0] : field name {String,Link}
	/// </param>
	var getFormFieldValue = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			Q.Promise.all([a]).then(function(values){
				var fieldName = values[0]
				console.log("getting value of field: "+fieldName);
				var val = "";
				switch(Xrm.Page.getAttribute(fieldName).getAttributeType()){
					case "lookup":
						val = Xrm.Page.getAttribute(fieldName).getValue() || "";
						if(val!==""){
							val = val[0].name
						}
						break;
					// case "datetime":
						// val = Xrm.Page.getAttribute(fieldName).getValue() || "";
						// if(val!==""){
							// val = val.localeFormat();
						// }
						// break;
					default:
					val = Xrm.Page.getAttribute(fieldName).getValue() || "";
						break;
				}
				resolve(val);
			});
		});
	}
	
	/// <summary>
	/// Gets field lookup property value in current form
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0] : field name {String,Link}
	/// @args[1] : property/ies name {String,Link} ["propName"]|["propName1,propName2,propName3"]
	/// @args[2] : associated lookup entity name {String,Link}
	/// @args[3] : associated lookup property/ies name {String,Link}["propName"]|["propName1,propName2,propName3"]
	/// </param>
	var getFormLookupValue = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			var b = se._checkForLink(args[1]);
			var c = se._checkForLink(args[2]);
			var d = se._checkForLink(args[3]);
			Q.Promise.all([a,b,c,d]).then(function(values){
				var fieldName = values[0];
				var property = values[1];
				var associatedLookupEntityName = values[2]||"";
				var associatedLookupProperty = values[3]||"";
				
				var makeRESTcall = function(/*passedResolve*/){
					if(associatedLookupEntityName != ""){
						property = "_"+property+"_value"
					}
					se.retrieveSingleEA([entity,id,property]).then(function(data){
						//TODO: prepare for multiple properties
						var result = data[property];
						if(associatedLookupEntityName != ""){
							se.retrieveSingleEA([associatedLookupEntityName,result,associatedLookupProperty]).then(function(data){
								var trueResult = data[associatedLookupProperty];
								var lookupObj = [];
								lookupObj[0] = {};
								lookupObj[0].id = "{"+result+"}";
								lookupObj[0].name = trueResult;
								lookupObj[0].entityType = associatedLookupEntityName;
								resolve(lookupObj);
							});
						}else{
							resolve(result);
						}
					});
				}
				
				console.log("getting value of property: "+property+" from lookup field: "+fieldName);
				var val = Xrm.Page.getAttribute(fieldName).getValue() || "";
				if(val != ""){
					if(val[0][property] != undefined){
						resolve(val[0][property]);
					}else{
						var id = val[0].id.replace(/{|}/g,"");
						var entity = val[0].entityType;
						if(typeof(val[0].keyValues)!=="undefined"){
							if(typeof(val[0].keyValues)==="string"){
								var parsedKeyValues = JSON.parse(val[0].keyValues);
								var propertyValue = parsedKeyValues[property] || parsedKeyValues[property+"_Value"];
								if(propertyValue == undefined){
									makeRESTcall();
								}else{
									resolve(propertyValue.value);
								}
							}else if(typeof(val[0].keyValues)==="object"){
								var propertyValue = val[0].keyValues[property] || val[0].keyValues[property+"_Value"];
								if(propertyValue == undefined){
									makeRESTcall();
								}else{
									resolve(propertyValue.value);
								}
							}
						}else{
							//rest call to get the data attribute
							makeRESTcall();
						}
					}
				}else{
					resolve(val);
				}
			});
		});
	}
	
	/// <summary>
	/// Sets field value in current form
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	field name {String,Link}
	/// @args[1]	:	field value {String,Link}
	/// </param>
	//TODO: type check, value conversions
	var setFormFieldValue = function(args){//mohlo by mit vic parametru fireOnChange - T/F, //force set submitMode// 
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			var b = se._checkForLink(args[1]);
			Q.Promise.all([a,b]).then(function(values){
				var fieldName = values[0];
				var newValue = values[1];
				console.log("setting field: "+fieldName+" to value: "+newValue);
				Xrm.Page.getAttribute(fieldName).setValue(newValue);
				if(Xrm.Page.getAttribute(fieldName).getSubmitMode()==="never"){
					Xrm.Page.getAttribute(fieldName).setSubmitMode("always");
				}
				//Xrm.Page.getAttribute(fieldName).fireOnChange();
				resolve(true);
			});
		});
	}
	
	/// <summary>
	/// Sets field required level in current form
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	field name {String,Link}
	/// @args[1]	:	required level {String,Link}
	/// </param>
	var setFormFieldRequiredLevel = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			var b = se._checkForLink(args[1]);
			Q.Promise.all([a,b]).then(function(values){
				var fieldName = values[0];
				var requiredLevel = values[1];
				console.log("setting field: "+fieldName+" to required level: "+requiredLevel);
				Xrm.Page.getAttribute(fieldName).setRequiredLevel(requiredLevel);
				resolve(true);
			});
		});
	}
	
	/// <summary>
	/// Saves the record synchronously with the options to close the form or open a new form after the save is completed.
	/// Both Xrm.Page.data.save and Xrm.Page.data.entity.save will save the record,
	///	but Xrm.Page.data.save provides callback functions after the save operation completes.
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	save command {String,Link} ["" | "saveandclose" |"saveandnew"]
	/// </param>
	var saveRecord = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			Q.Promise.all([a]).then(function(values){
				var saveCommand = values[0];
				console.log("saving record with command: "+saveCommand);
				Xrm.Page.data.entity.save(saveCommand);
				resolve(true);
			});
		});
	}
	
	/// <summary>
	/// Procces IF statement
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	operator {String}
	/// @args[1]	:	left side value {Anything}
	/// @args[2]	:	right side value {Anything}
	/// </param>
	var proccesIfStatement = function(args){
		var se = this;

		return new Q.Promise(function(resolve,reject){
			var a = args[0];
			var b = se._checkForLink(args[1]);
			var c = se._checkForLink(args[2]);
			Q.Promise.all([b,c]).then(function(values){
				var left = values[0];
				var right = values[1];
				switch(a) {
					case "==":
						if(left == right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case "===":
						if(left === right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case "!=":
						if(left != right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case "!==":
						if(left !== right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case ">":
						if(left > right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case ">=":
						if(left >= right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case "<":
						if(left < right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
					case "<=":
						if(left <= right){
							console.log("returning proccesIfStatement result: TRUE");
							resolve(true);
							break;
						}else{
							console.log("returning proccesIfStatement result: FALSE");
							resolve(false);
							break;
						}
				}
			});
		});
	}
	
	/// <summary>
	/// Create Dialog
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	type {String} [message,loading,confirm,form]
	/// @args[1]	:	title {String,Link}
	/// @args[2]	:	message {String,Link}
	/// @args[3]	:	timeout {Int,Boolean}
	/// @args[4]	:	??? {Anything}
	/// </param>
	var createDialog = function(args){
		var se = this;
		//get jQuery, jQueryUI, css...
		//type = ["confirm","message","form"]
		se["_generateDialog_"+args[0]](args);
	};
	
	var _generateDialog_message = function(args){
		//check if this
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[1]);	//title
			var b = se._checkForLink(args[2]);	//message
			var c = args[3] //timeout close OR false for manual
			Q.Promise.all([a,b]).then(function(values){
				var title = values[0];
				var message = values[1];
				
				var dialogHTML = '<div id="ScriptDialog" title="'+title+'">';
				dialogHTML += '<div class="ui-widget-content">'+message;
				dialogHTML += '</div></div>';
				var dialog = $(dialogHTML, window.top.document).dialog({
					autoOpen: true,
					height: "auto",
					width: "auto",
					modal: true,
					buttons:{
						Ok: function(){
							dialog.dialog( "close" );
						}
					},
					close: function(){
						console.log("dialog close");
						dialog.dialog( "destroy" );
						resolve(true);
					},
					create: function(){
						if(c && typeof(c)=="number"){
							setTimeout(function(){try{dialog.dialog( "close" );}catch(err){console.log(err);}},c);
						}
					}
				});
				dialog.parent("div").position({
					my: "center top",
					at: "center bottom",
					of: window.document
				});
			})
		});
	};
	
	var _generateDialog_confirm = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[1]);	//title
			var b = se._checkForLink(args[2]);	//message
			var c = args[3] //timeout close OR false for manual
			Q.Promise.all([a,b]).then(function(values){
				var title = values[0];
				var message = values[1];
				
				var dialogHTML = '<div id="ScriptDialog" title="'+title+'">';
				dialogHTML += '<div class="ui-widget">'+message;
				dialogHTML += '</div></div>';
				var dialog = $(dialogHTML, window.top.document).dialog({
					autoOpen: true,
					height: "auto",
					width: "auto",
					modal: true,
					buttons:{
						Ok: function(){
							dialog.dialog( "close" );
							resolve(true);
						},
						Cancel: function(){
							dialog.dialog( "close" );
							resolve(false);
						}
					},
					close: function(){
						console.log("dialog close");
						dialog.dialog( "destroy" );
						//resolve(true);
					},
					create: function(){
						if(c && typeof(c)=="number"){
							setTimeout(function(){try{dialog.dialog( "close" );}catch(err){console.log(err);}},c);
						}
					}
				});
				dialog.parent("div").position({
					my: "center top",
					at: "center bottom",
					of: window.document
				});
			})
		});
	};
	
	var retrieveSingleEA = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = _checkForLink(args[0]);
			var b = _checkForLink(args[1]);
			var c = _checkForLink(args[2]);
			
			Q.Promise.all([a,b,c]).then(function(values){
				var entity = values[0];
				var id = values[1];
				var property = (values[2]||"").split(",");
				$.ajax({
					type: "GET",
					contentType: "application/json; charset=utf-8",
					datatype: "json",
					url: _buildServerUrl(entity,id,property),
					beforeSend: function (XMLHttpRequest) {
						//XMLHttpRequest.setRequestHeader("Accept", "application/json");
						XMLHttpRequest.setRequestHeader("OData-MaxVersion", "4.0");
						XMLHttpRequest.setRequestHeader("OData-Version", "4.0");
						XMLHttpRequest.setRequestHeader("Accept", "application/json");
						XMLHttpRequest.setRequestHeader("Prefer", "odata.include-annotations=\"OData.Community.Display.V1.FormattedValue\"");

					},
					success: function (data, textStatus, XmlHttpRequest) {
						resolve(data);
					},
					error: function (XmlHttpRequest, textStatus, errorObject) {
						console.error(textStatus, errorObject);
						alert("OData Execution Error Occurred");
						reject(this);
					}
				});
			});
		});
	}
	
	var runFunctionByName = function(args){
		var a = args[0];
		var fcfg = window.ScriptEditor.loadedConfigs.filter(function(c){return c._config.FunctionName===a});
		if(fcfg.length===1){
			fcfg[0].run(0);
		}
		return new Q.Promise.resolve(true);
	}
	
	/// <summary>
	/// Sets field background color in current form
	/// </summary>
	/// <param name="args" type="array" mayBeNull="false" optional="false" >
	/// @args[0]	:	field name {String,Link}
	/// @args[1]	:	field color {String,Link}
	/// </param>
	var setFormFieldColor = function(args){
		var se = this;
		return new Q.Promise(function(resolve,reject){
			var a = se._checkForLink(args[0]);
			var b = se._checkForLink(args[1]);
			Q.Promise.all([a,b]).then(function(values){
				var fieldName = values[0];
				var color = values[1];
				console.log("setting field: "+fieldName+" to color: "+color);
				$("*[data-attributename='"+fieldName+"']",window.parent.document)[0].style.background = color;
				resolve(true);
			});
		});
	};
	
	var assign = function(){
		var se = this;
		//assign to correct event/field/button/whatever...
		if(config.Target.FieldName === "onLoad"){	//onLoad run right away
			se.run(0);
		}else if(config.Target.FieldName !== ""){	//addOnChange to Field
			var fieldName = config.Target.FieldName || "";
			var eventName = "addOnChange";
			var control = Xrm.Page.ui.controls.getByName(fieldName);
			var turboFormControl = Xrm.Page.getAttribute(fieldName);
			//TODO: decide logic, other cases
			if(turboFormControl != null){
				turboFormControl[eventName](function(){
					se.run(0);
				});
			}
			//if init run is true
			// if(config.Target.InitRun === true){
				// se.run(0);
			// }
			
		}
		
		//get ui
		//var controlUi = $("*[data-attributename='"+fieldName+"']");
		////$("td[id*='"+fieldName+"']").children("div");
		////$("td[id*='"+fieldName+"']").closest("tr");
		////$("*[data-attributename='"+fieldName+"']")
		//
	}
	
	var run = function (key){
		var se = this;
		if(!key){
			key = 0;
		}
		var current = config.NodeDataArray.filter(function(n){return n.key === key})[0];
		
		se[current.fName](current.args).then(function(data){
		//TODO: check current.useReturnValue == true ? data as args : default
			if(current.nextKey != null){
				if(current.nextKey.length == 2){
					if(data === true){
						se.run(current.nextKey[0]);
					}else{
						se.run(current.nextKey[1]);
					}
				}else if(current.nextKey.length == 1){ //only other possibility 
					se.run(current.nextKey[0]);
				}
			}else{
				return Q.Promise.resolve();
			}
		});
	}
	
	return {
		_config				:	_config,
		_checkForLink		:	_checkForLink,
		_buildServerUrl		:	_buildServerUrl,
		_generateDialog_message: _generateDialog_message,
		_generateDialog_confirm: _generateDialog_confirm,
		getFormFieldValue	:	getFormFieldValue,
		getFormLookupValue	:	getFormLookupValue,
		setFormFieldValue	:	setFormFieldValue,
		setFormFieldRequiredLevel: setFormFieldRequiredLevel,
		retrieveSingleEA	:	retrieveSingleEA,
		proccesIfStatement	:	proccesIfStatement,
		runFunctionByName	:	runFunctionByName,
		run					:	run,
		saveRecord			:	saveRecord,
		assign				:	assign,
		createDialog		:	createDialog,
		proccesStringStatement:	proccesStringStatement,
		proccesMathStatement:	proccesMathStatement,
		concatStrings		:	concatStrings,
		relayValue			:	relayValue,
		setFormFieldColor	:	setFormFieldColor
	};
};